#ifndef PATHWRITER_MULTIFILE_HEADER
#define PATHWRITER_MULTIFILE_HEADER

#include "pathwriter.hpp"

//this class implements the common functionality for all PathWriters which can write to several files at once.
//We use the CRTP idiom to get compile-time dispatch where we need it
template<typename T> class PathWriterMultiFile : public PathWriter {
public:
    virtual bool start();
    virtual bool writePaths(clp::Paths &paths, int type, double radius, int ntool, double z, double scaling, bool isClosed);
    virtual bool close();
    virtual ~PathWriterMultiFile() { close(); }
    bool writeToAll(clp::Paths &paths, int type, double radius, int ntool, double z, double scaling, bool isClosed);
    bool generic_for_ntool, generic_for_z, generic_for_type, generic_all, delegateWork;
    std::vector<std::shared_ptr<T>> subwriters;
protected:
    void init(std::string file, const char * extension, double epsilon, bool generic_for_type, bool generic_for_ntool, bool generic_for_z);
    bool matchZNtool(int type, int ntool, double z);
    int findOrCreateSubwriter(int type, double radius, int ntool, double z);
    //derived classes must implement a constructor without parameters, specificClose(), startWriter(), writePathsSpecific(), and endWriter()
    double z, epsilon;
    double radius;
    int type;
    int ntool;
    bool isopen;
    int currentSubwriter;
    //this has to be a vector of pointers because if the vector gets bigger, it will destroy and recreate the objects, interfering with the life cycle we have designed
    FILE * f;
    const char * extension;
};

enum DXFWMode { DXFAscii, DXFBinary };

//write to DXF file (either ascii or binary)
//TODO: currently, this only works on little-endian machines such as x86. If necessary, modify so it also work in different XXX-endians
template<DXFWMode mode> class DXFPathWriter : public PathWriterMultiFile<DXFPathWriter<mode>> {
public:
    DXFPathWriter(std::string file, double epsilon, bool generic_type, bool _generic_ntool, bool _generic_z);
    std::shared_ptr<DXFPathWriter<mode>> createSubWriter(std::string file, double epsilon, bool generic_type, bool _generic_ntool, bool _generic_z);
    bool startWriter();
    bool endWriter();
    bool writePathsSpecific(clp::Paths &paths, int type, double radius, int ntool, double z, double scaling, bool isClosed);
    bool specificClose();
};

typedef DXFPathWriter<DXFAscii>  DXFAsciiPathWriter;
typedef DXFPathWriter<DXFBinary> DXFBinaryPathWriter;

enum NanoscribeScanMode { PiezoScanMode, GalvoScanMode };
enum GalvoPositionMode { GalvoAlwaysCenter, GalvoMinimizeMovements };

typedef std::vector<std::pair<std::string, std::string>> ToolChanges;

typedef struct SimpleNanoscribeConfig {
    //these are configuration values, to be set by the user code
    double maxSquareLen; //in internal units

    NanoscribeScanMode scanmode;
    GalvoPositionMode galvomode;

    bool snapToGrid;
    clp::cInt gridStep; //in internal units

    std::string nanoscribeNumberFormatting;
    std::shared_ptr<ToolChanges> toolChanges;
    std::string beginScript, endScript;
    std::string beginGlobalScript, endGlobalScript;

    //these values are generated by calling init()
    double factor_internal_to_nanoscribe;
    SnapToGridSpec snapspec;
    std::string pointLineFormatting;
    std::string zoffsetFormatting;
    std::string addzdriveFormatting;
    double NanoscribePiezoRangeInternalUnits;
    double factor_input_to_nanoscribe;

    void init(MetricFactors &factors);
} SimpleNanoscribeConfig;

typedef std::vector<std::shared_ptr<SimpleNanoscribeConfig>> SimpleNanoscribeConfigs;

//convert toolpaths to Nanoscribe's GWL script, IN ONE VOLUME,
//(i.e., not suitable for toolpaths over a volume bigger than the volume addressable with the piezo/galvo).
//it is intended to be used with NanoscribeSplittingPathWriter
//ALSO: does not take into account the tool, except to write appropriate chunks of text in the scripts
//TODO: right now, handling of Z positions beyond the 300um limit is done transparently, but this will probably have to change to write in blocks by Z range
class SimpleNanoscribePathWriter : public PathWriterMultiFile<SimpleNanoscribePathWriter> {
    friend class NanoscribeSplittingPathWriter;
public:
    SimpleNanoscribePathWriter(PathSplitter &splitter, std::shared_ptr<SimpleNanoscribeConfig> _config, std::string file, double epsilon, bool generic_ntool, bool generic_z);
    std::shared_ptr<SimpleNanoscribePathWriter> createSubWriter(std::string file, double epsilon, bool generic_type, bool _generic_ntool, bool _generic_z);
    bool startWriter();
    bool endWriter();
    bool writePathsSpecific(clp::Paths &paths, int type, double radius, int ntool, double z, double scaling, bool isClosed);
    bool specificClose();
    //WARNING: writePaths() should not be called directly for this class
    virtual bool writeEnclosedPaths(PathSplitter::EnclosedPaths &encl, int type, double radius, int ntool, double z, double scaling, bool isClosed);
protected:
    bool canBePrintedInCurrentWindow(clp::Paths &paths);
    bool setupNToolAndZ(bool firstTime, int ntool, double z);
    PathSplitter &splitter;
    std::shared_ptr<SimpleNanoscribeConfig> config;
    clp::IntPoint currentWindowMin;
    clp::IntPoint currentWindowMax;
    clp::IntPoint StagePosition;
    clp::Path square;
    clp::Path lastSquare;
    double lastZ;
    int lastNTool;
    int current_z_block;
    bool firstTime;
    bool overrideGalvoMode;
};

//specialization of SplittingPathWriter for Nanoscribe: it writes a main GWL script that includes all other GWL scripts
class NanoscribeSplittingPathWriter : public SplittingPathWriter {
public:
    //either a single PathSplitterConfig, or one for each tool
    NanoscribeSplittingPathWriter(MultiSpec &_spec, SimpleNanoscribeConfigs _nanoconfigs, PathSplitterConfigs _splitterconfs, std::string file, bool generic_ntool = true, bool generic_z = true);
    virtual ~NanoscribeSplittingPathWriter() { close(); }
    virtual bool finishAfterClose(); //use this method to write a main script that includes all subscripts
protected:
    SimpleNanoscribeConfigs nanoconfigs;
};

#endif