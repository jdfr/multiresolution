# Multiresolution

This project is the core of the Multiresolution Layer Manufacturing (MLM) project: it contains the core multislicing engine, along with multiple back-ends and interfaces, as well as some minor utilities to edit PATHS files.

## Platforms

The project is mostly C++11, which can be compiled both under Linux/GCC, Windows/MinGW-64 and Windows/Visual Studio (requires 64-bit mode in all cases). The .Net bindings (MultiSlicerInterface) should be compilable in Mono (they do no fancy things, but I have not tried it). However, the AutoCAD plugins require AutoCAD 2013 or later, so Windows is a must for these.

## Compiling 

This project has been successfully compiled in MinGW-64 (with gcc 5.X and 6.X), Visual Studio 2013, and Debian unstable (2015-2017). While this project can be compiled on its own, it is better to compile it in the context of the MLM metaproject.

## Testing 

The project has no unit tests. In place of them, it has a set of tests that produce outputs, and then, if available, check that the outputs remain the same as in a previous invocation test (to that end, the results of the previous run must be in the directory `../bin/testprev`, while the current test is run in the subdirectory `../bin/test`). The `bin/test` directory can be regenerated by running again cmake with the same command-line configuration. Beware that, even if the results in both of these two directories were generated with the same code, there might be very slight changes in the results, but the comparator just warns if there is *any* difference between files, so there might be false positives that have to be closely examined.

Also, beware that some tests use as input STLs that are generated programmatically in other tests that run at the beginning, and other tests use as input the output of earlier tests. This project tests also to a slight degree the results of other projects, such as Slic3r's generation of gcode from PATHS files. The tests come in two flavours: *mini* for fast testing and *full* for more (but not full) coverage and a more stressing suite of edge cases. They are aggregated in targets that you can invoke through the build system (i.e., in the `../build` directory), such as:

* To run *all* tests, **not including** comparisons between files in `test` and `testprev`: `cmake --build . --target checkncomp --config Release`
* To run *all* tests, **including** comparisons between files in `test` and `testprev`: `cmake --build . --target check --config Release`
* To run just the tests that copy/generate the STL files: `cmake --build . --target putfiles --config Release`
* All these commands must be run from the directory were the project has the build system generated by cmake. Depending on the configuration options suplied to cmake, this might be either `../build` or `../build/multiresolution`. 

There are build options to add gcov instrumentation in the binaries. If these are set, the tests targets will be configured to generate coverage reports (by default with lcov, so no Windows support) after all the tests specified in the target are run.

The script `compare_tests.cmake` (with .bat and .sh aliases) can be used to perform tests in two versions of the whole system, to check that no big accidental changes are introduced after a code change. Each version of the whole system is defined as the git labels (commits, branches, etc.) to be checked out in each subsystem (pyclipper, clipper, Slic3r, multiresolution); if some of these labels are undefined, the current state of the subsystem is used (it is the responsibility of the programmer to select a consistent set of git labels so all subsystems are consistent).

## Examples

Usage examples are generated as part of the testing setup.

## History

This project started as a Python library using numpy for most data-intensive processing, with Cython bindings for C and C++ libraries and some CPU-intensive but non-easily vectorizable functions moved to C and called from Cython. Originally, a important goal for the library was to interoperate with .NET applications. At the time (mid-2015), there were some ways to integrate Python+numpy+C code in .NET (IronPython with Enthought's ports of numpy and Cython, and Python.NET), but it was decided to reimplement the main business logic in C++, exposing a (pure C, i.e. non C++) DLL interface, to minimize dependencies, among other reasons.

The project no longer has the goal to interoperate with .NET (although it still does, and the main example on how to use the DLL interface is a set of .NET bindings used by an AutoCAD plugin), but it has remained as a C++ codebase. I learnt C++11 on the go while developing this project, and it shows in the code, which resembles a geological sequence: some parts are pure C (originally C helper functions called from Cython), others feel like 80s C-with-classes, and in others I experiment with various topics such as writing a custom allocator to speed-up a legacy library, various examples of templates and template metaprogramming such as compile-time polymorphism (CRTP), making extensive use of move semantics, lambdas, etc.

## License

This project is released under the AGPLv3.